#!/usr/bin/perl

#DEADBEEF
$VAR1 = {
          'any' => {
                     'instr' => 996,
                     'mnem' => 'any',
                     'opcode' => '000003e4',
                     'size' => 4
                   },
          'backcommit' => {
                            'instr' => 263104,
                            'mnem' => 'backcommit',
                            'opcode' => '000403c0',
                            'param1' => 'address',
                            'size' => 8,
                            'terse' => 1
                          },
          'call' => {
                      'instr' => 263042,
                      'mnem' => 'call',
                      'opcode' => '00040382',
                      'param1' => 'address',
                      'size' => 8,
                      'terse' => 1
                    },
          'catch' => {
                       'instr' => 263059,
                       'mnem' => 'catch',
                       'opcode' => '00040393',
                       'param1' => 'address',
                       'size' => 8,
                       'terse' => 1
                     },
          'char' => {
                      'instr' => 263127,
                      'mnem' => 'char',
                      'opcode' => '000403d7',
                      'param1' => 'char',
                      'size' => 8
                    },
          'closecapture' => {
                              'instr' => 262912,
                              'mnem' => 'closecapture',
                              'opcode' => '00040300',
                              'param1' => 'slot',
                              'size' => 8,
                              'terse' => 1
                            },
          'commit' => {
                        'instr' => 262966,
                        'mnem' => 'commit',
                        'opcode' => '00040336',
                        'param1' => 'address',
                        'size' => 8,
                        'terse' => 1
                      },
          'condjump' => {
                          'instr' => 525089,
                          'mnem' => 'condjump',
                          'opcode' => '00080321',
                          'param1' => 'register',
                          'param2' => 'address',
                          'size' => 12
                        },
          'counter' => {
                         'instr' => 525142,
                         'mnem' => 'counter',
                         'opcode' => '00080356',
                         'param1' => 'register',
                         'param2' => 'value',
                         'size' => 12
                       },
          'end' => {
                     'instr' => 262360,
                     'mnem' => 'end',
                     'opcode' => '000400d8',
                     'param1' => 'code',
                     'size' => 8,
                     'terse' => 1
                   },
          'endreplace' => {
                            'instr' => 921,
                            'mnem' => 'endreplace',
                            'opcode' => '00000399',
                            'size' => 4,
                            'terse' => 1
                          },
          'fail' => {
                      'instr' => 843,
                      'mnem' => 'fail',
                      'opcode' => '0000034b',
                      'size' => 4,
                      'terse' => 1
                    },
          'failtwice' => {
                           'instr' => 912,
                           'mnem' => 'failtwice',
                           'opcode' => '00000390',
                           'size' => 4
                         },
          'jump' => {
                      'instr' => 262963,
                      'mnem' => 'jump',
                      'opcode' => '00040333',
                      'param1' => 'address',
                      'size' => 8,
                      'terse' => 1
                    },
          'maskedchar' => {
                            'instr' => 525157,
                            'mnem' => 'maskedchar',
                            'opcode' => '00080365',
                            'param1' => 'char',
                            'param2' => 'mask',
                            'size' => 12,
                            'terse' => 1
                          },
          'noop' => {
                      'instr' => 0,
                      'mnem' => 'noop',
                      'opcode' => '00000000',
                      'size' => 4
                    },
          'opencapture' => {
                             'instr' => 263068,
                             'mnem' => 'opencapture',
                             'opcode' => '0004039c',
                             'param1' => 'slot',
                             'size' => 8,
                             'terse' => 1
                           },
          'partialcommit' => {
                               'instr' => 263092,
                               'mnem' => 'partialcommit',
                               'opcode' => '000403b4',
                               'param1' => 'address',
                               'size' => 8
                             },
          'quad' => {
                      'instr' => 263038,
                      'mnem' => 'quad',
                      'opcode' => '0004037e',
                      'param1' => 'quad',
                      'size' => 8
                    },
          'range' => {
                       'instr' => 525245,
                       'mnem' => 'range',
                       'opcode' => '000803bd',
                       'param1' => 'from',
                       'param2' => 'until',
                       'size' => 12,
                       'terse' => 1
                     },
          'replace' => {
                         'instr' => 525128,
                         'mnem' => 'replace',
                         'opcode' => '00080348',
                         'param1' => 'slot',
                         'param2' => 'address',
                         'size' => 12,
                         'terse' => 1
                       },
          'ret' => {
                     'instr' => 928,
                     'mnem' => 'ret',
                     'opcode' => '000003a0',
                     'size' => 4,
                     'terse' => 1
                   },
          'set' => {
                     'instr' => 2098122,
                     'mnem' => 'set',
                     'opcode' => '002003ca',
                     'param1' => 'set',
                     'size' => 36,
                     'terse' => 1
                   },
          'skip' => {
                      'instr' => 262960,
                      'mnem' => 'skip',
                      'opcode' => '00040330',
                      'param1' => 'number',
                      'size' => 8
                    },
          'span' => {
                      'instr' => 2098145,
                      'mnem' => 'span',
                      'opcode' => '002003e1',
                      'param1' => 'set',
                      'size' => 36
                    },
          'testany' => {
                         'instr' => 262918,
                         'mnem' => 'testany',
                         'opcode' => '00040306',
                         'param1' => 'address',
                         'size' => 8
                       },
          'testchar' => {
                          'instr' => 525210,
                          'mnem' => 'testchar',
                          'opcode' => '0008039a',
                          'param1' => 'address',
                          'param2' => 'char',
                          'size' => 12
                        },
          'testquad' => {
                          'instr' => 525275,
                          'mnem' => 'testquad',
                          'opcode' => '000803db',
                          'param1' => 'address',
                          'param2' => 'quad',
                          'size' => 12
                        },
          'testset' => {
                         'instr' => 2360163,
                         'mnem' => 'testset',
                         'opcode' => '00240363',
                         'param1' => 'address',
                         'param2' => 'set',
                         'size' => 40
                       },
          'trap' => {
                      'instr' => 4278255615,
                      'mnem' => 'trap',
                      'opcode' => 'ff00ffff',
                      'size' => 4
                    },
          'var' => {
                     'instr' => 263150,
                     'mnem' => 'var',
                     'opcode' => '000403ee',
                     'param1' => 'slot',
                     'size' => 8,
                     'terse' => 1
                   }
        };


#/DEADBEEF

my $inputfile = shift @ARGV;
my $outputfile = shift @ARGV;

my ($in, $out);

if ($inputfile eq '-') {
  $in = *STDIN;
} else {
  open $in, '<', $inputfile || die "Could not open $inputfile";
}

if (!defined($outputfile)) {
  $outputfile = '-';
}
if ($outputfile eq '-') {
  $out = *STDOUT;
} else {
  open $out, '>', $outputfile || die "Could not open $outputfile";
}

my $labelmap;
if ($inputfile ne '-' && -f "$inputfile.labelmap") {
  my $lfile = absorb_binary("$inputfile.labelmap");
  while (length($lfile)) {
    $lfile =~ s/^(....)//s;
    my $offset = dec32bit($1);
    $lfile =~ s/^([^\0]+)\0//;
    my $label = $1;
    $labelmap->{$label} = $offset;
  }
}

my $bytecode = absorb_binary($inputfile);

print $out "-- Generated at " . localtime . " by gen0 disassembler.\n";

my $offset = 0;
while ($offset < length($bytecode)) {
  my @labels = labelreverse($offset);
  foreach my $label (@labels) {
    print $out "$label:\n";
  }
  my $opcode = dec32bit(substr($bytecode, $offset, 4));
  if ($opcode == $INSTR_NOOP) {
    print $out "$offset: noop";
    $offset += 4;
  } elsif ($opcode == $INSTR_ANY) {
    print $out "$offset: any";
    $offset += 4;
  } elsif ($opcode == $INSTR_BACKCOMMIT) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: backcommit $address";
    $offset += 8;
  } elsif ($opcode == $INSTR_SKIP) {
    my $n = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: skip $n";
    $offset += 8;
  } elsif ($opcode == $INSTR_CALL) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    my $funclabel = labelreverse($address);
    if (!defined($funclabel)) {
      print $out "$offset: call $address";
    } else {
      print $out "$offset: call $address -- ($funclabel)";
    }
    $offset += 8;
  } elsif ($opcode == $INSTR_CHAR) {
    my $char = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: char " . sprintf("%.2x", $char);
    $offset += 8;
  } elsif ($opcode == $INSTR_MASKEDCHAR) {
    my $char = dec32bit(substr($bytecode, $offset + 4, 4));
    my $mask = dec32bit(substr($bytecode, $offset + 8, 4));
    print $out "$offset: maskedchar " . sprintf("%.2x", $char) .
               " " . sprintf("%.2x", $mask);
    $offset += 12;
  } elsif ($opcode == $INSTR_QUAD) {
    my $char = unpack('N', substr($bytecode, $offset + 4, 4));
    print $out "$offset: quad " . sprintf("%.8x", $char);
    print $out "-- " . chr(($char>>24)&0xff) . chr(($char>>16)&0xff) . chr(($char>>8)&0xff) . chr($char&0xff) . ' ';
    $offset += 8;
  } elsif ($opcode == $INSTR_CATCH) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: catch $address";
    $offset += 8;
  } elsif ($opcode == $INSTR_CLOSECAPTURE) {
    my $slot = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: closecapture $slot";
    $offset += 8;
  } elsif ($opcode == $INSTR_COMMIT) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: commit $address";
    $offset += 8;
  } elsif ($opcode == $INSTR_END) {
    my $code = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: end $code";
    $offset += 8;
  } elsif ($opcode == $INSTR_FAIL) {
    print $out "$offset: fail";
    $offset += 4;
  } elsif ($opcode == $INSTR_FAILTWICE) {
    print $out "$offset: failtwice";
    $offset += 4;
  } elsif ($opcode == $INSTR_JUMP) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: jump $address";
    $offset += 8;
  } elsif ($opcode == $INSTR_OPENCAPTURE) {
    my $slot = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: opencapture $slot";
    $offset += 8;
  } elsif ($opcode == $INSTR_PARTIALCOMMIT) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: partialcommit $address";
    $offset += 8;
  } elsif ($opcode == $INSTR_REPLACE) {
    my $address1 = dec32bit(substr($bytecode, $offset + 4, 4));
    my $address2 = dec32bit(substr($bytecode, $offset + 8, 4));
    print $out "$offset: replace $address1 $address2";
    $offset += 12;
  } elsif ($opcode == $INSTR_STARTREPLACE) {
    print $out "$offset: startreplace";
    $offset += 4;
  } elsif ($opcode == $INSTR_ENDREPLACE) {
    print $out "$offset: endreplace";
    $offset += 4;
  } elsif ($opcode == $INSTR_RET) {
    print $out "$offset: ret";
    $offset += 4;
  } elsif ($opcode == $INSTR_SET) {
    print $out "$offset: set ";
    for (my $i=0; $i < 32; $i++) {
      print $out sprintf("%.2x", ord(substr($bytecode, $offset + 4 + $i, 1)));
    }
    if ($ENV{SHOWSET}) {
      debugset($bytecode, $offset + 4);
    }
    $offset += 36;
  } elsif ($opcode == $INSTR_SPAN) {
    print $out "$offset: span ";
    for (my $i=0; $i < 32; $i++) {
      print $out sprintf("%.2x", ord(substr($bytecode, $offset + 4 + $i, 1)));
    }
    if ($ENV{SHOWSET}) {
      debugset($bytecode, $offset + 4);
    }
    $offset += 36;
  } elsif ($opcode == $INSTR_TESTANY) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: testany $address";
    $offset += 8;
  } elsif ($opcode == $INSTR_TESTCHAR) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    my $char = dec32bit(substr($bytecode, $offset + 8, 4));
    print $out "$offset: testchar " . sprintf("%.2x", $char) . " $address";
    $offset += 12;
  } elsif ($opcode == $INSTR_TESTQUAD) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    my $quad = unpack('N', substr($bytecode, $offset + 8, 4));
    print $out "$offset: testquad " . sprintf("%.8x", $char) . " $address";
    $offset += 12;
  } elsif ($opcode == $INSTR_TESTSET) {
    my $address = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: testset ";
    for (my $i=0; $i < 32; $i++) {
      print $out sprintf("%.2x", ord(substr($bytecode, $offset + 8 + $i, 1)));
    }
    print $out " $address";
    if ($ENV{SHOWSET}) {
      debugset($bytecode, $offset + 8);
    }
    $offset += 40;
  } elsif ($opcode == $INSTR_VAR) {
    my $var = dec32bit(substr($bytecode, $offset + 4, 4));
    print $out "$offset: var $var";
    $offset += 8;
  } elsif ($opcode == $INSTR_COUNTER) {
    my $register = dec32bit(substr($bytecode, $offset + 4, 4));
    my $value = dec32bit(substr($bytecode, $offset + 8, 4));
    print $out "$offset: counter $register $value";
    $offset += 12;
  } elsif ($opcode == $INSTR_CONDJUMP) {
    my $register = dec32bit(substr($bytecode, $offset + 4, 4));
    my $jump = dec32bit(substr($bytecode, $offset + 8, 4));
    print $out "$offset: condjump $register $jump";
    $offset += 12;
  } else {
    print $out "-- Unknown opcode $opcode\n";
    die "Unknown opcode $opcode";
  }
  print $out "\n";
}

sub absorb_binary
{
  my $result = '';
  my $path = shift; die "Found not found" if (! -f $path);
  die "Error $@ opening $bytecodefile" if (!open(FILE, '<', $path));
  binmode FILE;
  my $buf;
  while (1) {
    my $n = sysread(FILE, $buf, 1024);
    if (!$n) {
      close FILE;
      return $result;
    }
    $result .= $buf;
  }
}

sub dec32bit
{
  my $str = shift;
  my $byte0 = ord(substr($str, 0, 1));
  my $byte1 = ord(substr($str, 1, 1));
  my $byte2 = ord(substr($str, 2, 1));
  my $byte3 = ord(substr($str, 3, 1));
  if ($byte0 != ($byte1 ^ $byte2 ^ $byte3)) {
    die "Checksum failure.";
  }
  return (
    ($byte1 << 16) |
    ($byte2 << 8) |
    $byte3
  );
}

sub labelreverse
{
  my $address = shift;
  my @result;
  foreach my $key (keys(%{$labelmap})) {
    if ($labelmap->{$key} eq $address) {
      if (!defined($result) || length($key) < length($result)) {
        push @result, $key;
      }
    }
  }
  return (wantarray ? @result : $result[0]);
}

sub debugset
{
  my ($bytecode, $offset) = @_;
  for (my $i=0; $i < 32; $i++) {
    my $byte = substr($bytecode, $offset + $i, 1);
    for (my $j=0; $j < 8; $j++) {
      if (ord($byte) & (1 << $j)) {
        my $value = (($i * 8) + $j);
        print $out "\n-- SET: " . sprintf("%.2x", $value);
        if ($value > 32 && $value < 127) {
          print $out " '" . chr($value) . "'";
        }
      }
    }
  }
}

1;
