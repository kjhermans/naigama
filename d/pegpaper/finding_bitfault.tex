\section{Finding: Bitfault Checking Mechanisms}

\subsection{The Simple Case}

The following grammar:

\begin{myquote}
\begin{verbatim}
DATA <- .+

\end{verbatim}
\end{myquote}

Yielding the following assembly:

\begin{myquote}
\begin{verbatim}
0: call 20
8: end 0
16: any
20: catch 40
28: any
32: partialcommit 28
40: ret
44: end 0

\end{verbatim}
\end{myquote}

Undergoes a sequential single bit toggle for each bit of the resulting
bytecode. The engine is fed a happy flow (short) piece of data
(in the case of this grammar, any data will do).
Ideally, the engine would always detect this and return an
error representing that. However, the engine as it stands, sometimes
returns zero (no error). The result of all bitflips are listed below
(416 bits total in the bytecode, Naigama version 0.3.6):

\begin{myquote}
\begin{verbatim}
Code   0 occurence 99   // success
Code -19 occurence 3    // stack corruption
Code -20 occurence 209  // bad opcode
Code -21 occurence 104  // overflow (jump out of bounds)
Code -32 occurence 1    // endless loop

\end{verbatim}
\end{myquote}

This seems like a lot of successful exits, however, there are two unchecked
'end' instructions with a 32 bit parameter (end code), and also: the second
'end' instruction is completely out of reach, so 96 of the 99 successful
exits are still quite harmless.

\begin{myquote}
\begin{verbatim}
-- Bit 96
0: call 16
8: end 16777216
16: any
20: catch 40
28: any
32: partialcommit 28
40: ret
44: end 0

\end{verbatim}
\end{myquote}
\textit{Example of a 'harmless' bit flip}

The remaining three mess up, because they change jump instructions
which accidentally end up well enough:

\begin{myquote}
\begin{verbatim}
-- Bit 58
0: call 20
8: end 0
16: any
20: catch 40
28: any
32: partialcommit 28
40: ret
44: end 0

\end{verbatim}
\end{myquote}

Here, the offset in the 'call' instruction is changed from 16 to 20, passing
the 'any' instruction, going directly into the endless loop, making this
bytecode equivalent to '.*' instead of '.+'.

\begin{myquote}
\begin{verbatim}
-- Bit 218
0: call 16
8: end 0
16: any
20: catch 44
28: any
32: partialcommit 28
40: ret
44: end 0

\end{verbatim}
\end{myquote}

Here, the offset in the 'catch' instruction is changed from 40 to 44,
jumping to the last 'end' instruction instead of to the 'ret' instruction.
The net effect is the same.

\begin{myquote}
\begin{verbatim}
-- Bit 221
0: call 16
8: end 0
16: any
20: catch 8
28: any
32: partialcommit 28
40: ret
44: end 0

\end{verbatim}
\end{myquote}

Here, the offset in the 'catch' instruction is changed from 40 to 8,
jumping to the first 'end' instruction instead of to the 'ret' instruction.
The net effect is the same.

\subsection{A More Complex Case}

The following grammar:

\begin{myquote}
\begin{verbatim}
JSON         <- %s* HASH %s*
HASH         <- '{' %s* OPTHASHELTS %s* '}'
OPTHASHELTS  <- HASHELTS / ...
HASHELTS     <- HASHELT %s* ',' %s* HASHELTS / HASHELT
HASHELT      <- STRING %s* ':' %s* VALUE
ARRAY        <- '[' %s* OPTARRAYELTS %s* ']'
OPTARRAYELTS <- ARRAYELTS / ...
ARRAYELTS    <- VALUE %s* ',' %s* ARRAYELTS / VALUE
VALUE        <- STRING / FLOAT / INT / BOOL / NULL / HASH / ARRAY
STRING       <- { '"' [^"]* '"' }
INT          <- { [0-9]+ }
FLOAT        <- { [0-9]* '.' [0-9]+ }
BOOL         <- { 'true' / 'false' }
NULL         <- { 'null' }

\end{verbatim}
\end{myquote}

With a JSON input that touches on all of the grammar's aspects:

\begin{myquote}
\begin{verbatim}
{"widget": {
    "debug": true,
    "window": {
        "title": "Sample Konfabulator Widget",
        "name": "main_window",
        "width": 500,
        "height": 500
    },
    "image": {
        "src": { "foo" : "bar", "bar" : 0.23 },
        "name": "sun1",
        "hOffset": 250.0,
        "vOffset": 250.5,
        "alignment": "center"
    },
    "text": {
        "data": [ "some", "sub", "array", 3, 5.7, false, null ],
        "size": 36,
        "style": null,
        "name": "text1",
        "hOffset": 250,
        "vOffset": 100,
        "alignment": "center",
        "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"
    }
}}

\end{verbatim}
\end{myquote}

Will yield the following statistics wrt exit codes:

\begin{myquote}
\begin{verbatim}
Code   1 occurence 437   // parser failure
Code   0 occurence 5044  // success
Code -19 occurence 144   // stack corruption
Code -20 occurence 4521  // bad opcode
Code -21 occurence 1603  // overflow
Code -23 occurence 322   // action list
Code -32 occurence 25    // endless loop
                  -----+
                  12096

\end{verbatim}
\end{myquote}

The amount of parser failures is explainable: this bytecode contains
a large amount of sets. Sets are 32 bytes long and a bitflip in them
can cause both false positives and false negatives in parsing, making
the engine exit as if the input had been incorrect. However, most bitflips
in bytecode sets will not result in a failure at all: since most of the
bits in most sets are zero, and this case tests a happy flow, most sets
will only become more, but unnoticedly, 'inclusive'.

This is the major reason for the large amount of successful exits.

Now we run the compiler with traps. The result:

\begin{myquote}
\begin{verbatim}
Code   0 occurence 1     // success
Code -19 occurence 3     // stack corruption
Code -20 occurence 70    // bad opcode
Code -21 occurence 21    // overflow
Code -29 occurence 12896 // trap
Code -32 occurence 1     // endless loop
                   ----+
                   12992

\end{verbatim}
\end{myquote}

The result is rather dramatic. There are more instructions (7\%) in the bytecode
(this compiler generates traps before and after the assembly for each rule only,
but could emit a lot more of them (see [Section \ref{sec:traps}]))
but the amount of successful exits decreases to almost zero.

In fact, the only successful change comes when 'call 16' at offset zero
is changed to 'call 272', and at offset 272 we find a 'ret' instruction.
