\section{Rationale}

In the whitepapers of Ierusalemschi et al \cite{bib:peg}
on Parsing Expression Grammars,
an assembly language is proposed that grammar is
compiled to, transforming a potentially infinitely deep structure
description into a list of instructions, allowing a simple state machine
with an endless loop to execute what would otherwise require 
ecursion in the execution of the parser.

It's a simple, elegant, efficient and secure concept:
with somewhere around 20 instructions, one can
formulate all conditions that a (text) parser could encounter
to a relatively deep level of syntactic understanding (even down
to such things as dynamically matching open- and closing XML tags,
for example).

This assembly language's instructions however,
oftentimes perform a combination of underlying manipulations of the
state machine, of which many make a repeated appearance.
For example, the \texttt{commit $<$label$>$} instruction is assumed to
perform the following steps:

\begin{itemize}
\item Pop a 'choice' element off the stack (must be the top element).
\item Jump to $<$label$>$
\end{itemize}

Where the \texttt{FAIL} condition (and the \texttt{fail} instruction)
is assumed to:

\begin{itemize}
\item Pop any item that isn't a 'choice' element off the stack.
\item Pop a 'choice' element off the stack (must now be the top element).
\item Recreate the machine state stored in that element.
\item Jump to the offset stored in that element.
\end{itemize}

And the \texttt{partialcommit $<$label$>$} instruction is assumed to
 \footnote{The expansion of the 'partialcommit' instruction has been purposely
worded in a convoluted manner; the original paper means the 'partialcommit'
as an optimization, where the 'choice' element on the stack isn't popped
and subsequently pushed, but \textit{updated}. In this paper, I propose
a different model of stack, that allows for efficient popping and pushing.}
:

\begin{itemize}
\item Pop a 'choice' element off the stack (must be the top element).
\item Update the input position in the machine state stored in that element.
\item Push the 'choice' element back on the stack.
\item Jump to $<$label$>$
\end{itemize}

However, if we look at the way all these instructions are conceptualised,
we can see a lot of similarities: the stack is pushed onto, and popped from,
the input position is guarded and increased, and there are jumps.
These should all be familiar to people who know 'proper' assembly
languages such as i386 or ARM. Note that the goal of this paper is not
to promote compiling down to an \textit{actual} assembly language, but
rather to one that is still abstract, but has more similarities with
those assembly languages.

Wouldn't it be worth exploring, then,
if the 'sub instructions' were somehow made more concrete, and actually
compile a PEG not to the whitepaper's assembly language, but to one that
is more elementary? Let's explore the arguments as to why this could be so.
That is to say: why pursuing another, 'deeper' assembly for PEG's could be
beneficial.

\begin{itemize}
\item For one, 'deeper', more 'CPU like' assembly instructions can be monitored
more ...
\item There could be (even) fewer of them.
\item And it could yield faster and / or yield better optimizations and
thereafter be faster.
\item Hardware implementations of the machine could be easier to implement.
\end{itemize}

The obvious downsides, from a first glance, would be:
The bytecode would be bigger; the original bytecode is also a means to
compress functional logic. The upside to that is that the machine size
would be smaller.
More elementary instructions also lack security, because they lack more
context in which their monitoring could take place.
Forensics, trying to discover why a piece of grammar would yield a
certain piece of bytecode, would be more difficult.
