\subsection{Measure: Modularization of Toolchain}

\subsubsection{Modules}
Naigama cuts the process of parsing into five potential stages, each with
their respective inputs and outputs. Outputs of a stage acts as input
for the next. The stages / modules are:

\begin{itemize}
\item{Compiler. Takes grammar as input and outputs assembly.}
\item{Optimizer. Takes assembly as input and outputs (optimized) assembly.}
\item{Assembler. Takes assembly as input and outputs bytecode.}
\item{Engine. Takes bytecode and the input and outputs the action list.}
\item{Action Processor. Executes the action list on the input.}
\end{itemize}

On top of this, Naigama also provides a disassembler (to verify that
the bytecode produced by the assembler is actually being produced correctly),
and has a debugger capability built into the engine.

Advantages of modularization are:

\begin{itemize}
\item{Drop in replacements. For example, if one does't trust the compiler
      per se, one can introduce only another compiler, without having to
      recreate the entire toolchain.}
\item{Foregoing modules, for example:}
  \begin{itemize}
  \item{Write assembly from scratch (and forego the compiler, or have
        another type of compiler altogether (for example, P4 \cite{bib:p4})).}
  \item{Make the use of the optimizer optional (for example, to check
        whether optimized and unoptimized assembly yields the same results
        on an input).}
  \item{Forego the use of the action processor, when you know there aren't
        any actions to process (matching inputs is fine in itself).}
  \end{itemize}
\item{Reversing the output of modules. Bytecode can be reduced to assembly
      by the disassembler. Other reversals are under study.}
\end{itemize}

Modularization addresses [Threat \thethreatbcerror], by allowing modules
to be replaced, foregone and / or reversed, making the process by which
the intention of the person drafting policy is converted into bytecode,
more free and more transparent.

LPEG \cite{bib:lpeg} by contrast, compiles directly from grammar to bytecode,
but can yield a decompiled assembly output in debug mode
[lpprint.c, which requires LPEG\_DEBUG to be \#defined.] This assembly
however, can not be re-introduced into the chain.

\subsubsection{Artefact: Slot Map}
The Naigama compiler can be instructed to emit a secondary file called
the slot map. This file contains a mapping from 'intuitive' (that is,
derived from rule names and textual data from the production definition)
to slot numbers of capture regions that the
compiler encountered during its pass over the grammar.

A slot map enables the developer to use names for capture regions instead
of index numbers (which can shift when the grammar is rewritten), possibly
preventing mistakes in Naigama library using code.

\subsubsection{Artefact: Label Map}
The Naigama assembler can be instructed to emit a secondary file called
the label map. This file contains a mapping from label names, as created
by the compiler, to their offsets in the bytecode.

A label map allows for better debugging, as offsets in the bytecode
can be reduced to more intuitively named labels.

\subsubsection{Tooling: Disassembler}

Naigama comes with a disassembler (in ./bin/disassembler), which recreates
the Naigama assembly from bytecode. The output of the disassembler prefixes
all instructions with a label, consisting of its offset in the bytecode,
in decimal (the reason that labels may start with a number in Naigama).

\subsubsection{Tooling: Debugger}

The Naigama engine can be run in debugging mode. In this case, one can
interactively step through the parsing process, instruction by instruction,
and when the FAIL state is invoked. The bytecode is run in the debugger
when the '-d' flag is used on the engine.

\begin{myquote}
\begin{verbatim}
$ ./src/gen2/main/engine/naie \
  -c ./src/gen1/grammar/grammar.byc \
  -l ./src/gen1/grammar/grammar.byc.labelmap \
  -i ./src/gen1/grammar/grammar.naig \
  -d -v

\end{verbatim}
\end{myquote}
\textit{Example of the invocation of the Naigama engine as debugger.}

