-- Naigama Grammar Grammar

GRAMMAR            <- ( DEFINITION+ / SINGLE_EXPRESSION ) END

__prefix           <- ( '--' [^\n]* '\n' / %s+ )*
END                <- !.

DEFINITION         <- RULE
SINGLE_EXPRESSION  <- EXPRESSION

RULE               <- { IDENT } OPTARGS LEFTARROW EXPRESSION
EXPRESSION         <- { TERMS } OR NOTHING /
                      { TERMS } OR EXPRESSION /
                      { TERMS } /
                      CALL

TERMS              <- { TERM }+
TERM               <- { NAMESPACE } / { ENDOWEDMATCHER }
NAMESPACE          <- NSOPEN EXPRESSION NSCLOSE
ENDOWEDMATCHER     <- { NOT / AND }? MATCHER { QUANTIFIER }?
QUANTIFIER         <- '?' /
                      '+' /
                      '*' /
                      '^' { [0-9]+ } '-' { [0-9]+ } /
                      '^' '-' { [0-9]+ } /
                      '^' { [0-9]+ } '-' /
                      '^' { [0-9]+ } /
                      '^$' { IDENT }
MATCHER            <- { ANY } /
                      { SET } /
                      { STRING } /
                      { BITMASK } /
                      { HEXLITERAL } /
                      { VARCAPTURE } /
                      { CAPTURE } /
                      { GROUP } /
                      { MACRO } /
                      { VARREFERENCE } /
                      { REFERENCE }

BITMASK            <- '|' [0-9a-fA-F]^2 '|' [0-9a-fA-F]^2 '|'

VARCAPTURE         <- CBOPEN COLON { IDENT } ( SEMICOLON { TYPE } )? COLON
                      EXPRESSION { CBCLOSE } CAPTUREEND
CAPTURE            <- CBOPEN EXPRESSION { CBCLOSE } CAPTUREEND
GROUP              <- BOPEN EXPRESSION { BCLOSE }
CAPTUREEND         <- ( REPLACE / RECYCLE / NSRANGE )?

NSRANGE            <- '#' { [0-9]+ } '-' { [0-9]+ } /
                      '#' '-' { [0-9]+ }
                      '#' { [0-9]+ }

SET                <- ABOPEN { SETNOT? } (
                        { '\\' ([nrtv\\\]\-] / [0-9]^3) / [^\\\]] } '-' 
                        { '\\' ([nrtv\\\]\-] / [0-9]^3) / [^\\\]] }
                        /
                        { '\\' ([nrtv\\\]\-] / [0-9]^3) / [^\\\]] }
                      )+ { ABCLOSE }

VARREFERENCE       <- '$' ( { IDENT } / { NUMBER } )
REFERENCE          <- IDENT !( OPTARGS LEFTARROW )

TYPE               <- 'uint32' /
                      'int32' /
                      'unet32' /
                      'net32' /
                      'decimal' /
                      IDENT

REPLACE            <- RIGHTARROW { REPLACETERMS }
REPLACETERMS       <- REPLACETERM+
REPLACETERM        <- { STRINGLITERAL } / { HEXLITERAL } / { VARREFERENCE }

RECYCLE            <- FATARROW { IDENT }

IDENT              <- [a-zA-Z_] [a-zA-Z_0-9]^-63
LEFTARROW          <- '<-'
RIGHTARROW         <- '->'
FATARROW           <- '=>'
NOT                <- '!'
AND                <- '&'
MACRO              <- '%' [a-zA-Z] [a-zA-Z0-9]*
HEXLITERAL         <- '0x' [0-9a-fA-F]^2
NUMBER             <- [0-9]+
STRINGLITERAL      <- '\'' ( '\\' ([nrtv\\'] / [0-9]^3) / [^'\\] )* '\''
STRING             <- STRINGLITERAL 'i'?
OR                 <- '/'
ANY                <- '.'
NOTHING            <- '...'
CBOPEN             <- '{'
COLON              <- ':'
CBCLOSE            <- '}'
BOPEN              <- '('
BCLOSE             <- ')'
ABOPEN             <- '['
ABCLOSE            <- ']'
SETNOT             <- '^'
SEMICOLON          <- ';'
COMMA              <- ','
LT                 <- '<'
GT                 <- '>'
NSOPEN             <- '[['
NSCLOSE            <- ']]'

--

OPTARGS            <- { ARGS }?
ARGS               <- BOPEN { IDENT } ( COMMA { IDENT } )* BCLOSE
CALL               <- LT { IDENT } { ARGS } GT

-- scripting engine

SCRIPT         <- ( TOPSTMT )*
TOPSTMT        <- { FUNCDECL } / { IMPORTSTMT }
IMPORTSTMT     <- KW_IMPORT STRINGLITERAL SEMICOLON
LOWSTMT        <- { ST_IF } /
                  { ST_WHILE } /
                  { ST_RETURN } /
                  { ST_OTHER } /
                  { VARDECL } /
                  { ASSIGNMENT } /
                  ( EXPRESSION )? SEMICOLON

FUNCDECL       <- KW_FUNCTION S+ IDENT FUNCPARAMDECL FUNCBODY
FUNCPARAMDECL  <- BOPEN { ( IDENT ( COMMA IDENT )* )? } BCLOSE
FUNCBODY       <- CBOPEN { LOWSTMT* } CBCLOSE

ST_IF          <- KW_IF BOPEN { EXPRESSION } BCLOSE
                    CBOPEN { LOWSTMT* } CBCLOSE
                    { IF_ELSEIF* }
                    { IF_ELSE? }
IF_ELSEIF      <- KW_ELSEIF BOPEN { EXPRESSION } BCLOSE
                    CBOPEN { LOWSTMT* } CBCLOSE 
IF_ELSE        <- KW_ELSE CBOPEN { LOWSTMT* } CBCLOSE

ST_WHILE       <- KW_WHILE BOPEN { EXPRESSION } BCLOSE
                    CBOPEN { LOWSTMT* } CBCLOSE

ST_RETURN      <- KW_RETURN { EXPRESSION? } SEMICOLON
ST_OTHER       <- ( KW_BREAK / KW_CONTINUE ) SEMICOLON

VARDECL        <- KW_VAR S+ IDENT ( ASSIGN { EXPRESSION } )? SEMICOLON

ASSIGNMENT     <- IDENT ASSIGNS EXPRESSION SEMICOLON

-- Copied from https://en.cppreference.com/w/c/language/operator_precedence
--
-- Precedence 	Operator 	Description 	Associativity
-- 1 	++ -- 		Suffix/postfix increment and decrement 	Left-to-right
-- 	() 		Function call
-- 	[] 		Array subscripting
-- 	. 		Structure and union member access
-- 	-> 		Structure and union member access through pointer
-- 	(type){list} 	Compound literal(C99)
-- 2 	++ -- 		Prefix increment and decrement[note 1] 	Right-to-left
-- 	+ - 		Unary plus and minus
-- 	! ~ 		Logical NOT and bitwise NOT
-- 	(type) 		Cast
-- 	* 		Indirection (dereference)
-- 	& 		Address-of
-- 	sizeof 		Size-of[note 2]
-- 	_Alignof 	Alignment requirement(C11)

-- 3 	* / % 		Multiplication, division, and remainder Left-to-right
-- 4 	+ - 		Addition and subtraction
-- 5 	<< >> 		Bitwise left shift and right shift
-- 6 	< <= 		For relational operators < and ≤ respectively
-- 	> >= 		For relational operators > and ≥ respectively
-- 7 	== != 		For relational = and ≠ respectively
-- 8 	& 		Bitwise AND
-- 9 	^ 		Bitwise XOR (exclusive or)
-- 10 	| 		Bitwise OR (inclusive or)
-- 11 	&& 		Logical AND
-- 12 	|| 		Logical OR

-- 13 	?: 		Ternary conditional[note 3] 	Right-to-Left
-- 14 	= 		Simple assignment
-- 	+= -= 		Assignment by sum and difference
-- 	*= /= %= 	Assignment by product, quotient, and remainder
-- 	<<= >>= 	Assignment by bitwise left shift and right shift
-- 	&= ^= |= 	Assignment by bitwise AND, XOR, and OR
-- 15 	, 		Comma 	Left-to-right 

EXPRESSION     <- BINOP_P12

BINOP_P12      <- { BINOP_P11 } ( OR BINOP_P11 )*
BINOP_P11      <- { BINOP_P10 } ( AND BINOP_P10 )*
BINOP_P10      <- { BINOP_P09 } ( BITOR BINOP_P09 )*
BINOP_P09      <- { BINOP_P08 } ( BITXOR BINOP_P08 )*
BINOP_P08      <- { BINOP_P07 } ( BITAND BINOP_P07 )*
BINOP_P07      <- { BINOP_P06 } ( ( EQUALS / NEQUALS ) BINOP_P06 )*
BINOP_P06      <- { BINOP_P05 } ( ( LTEQ / LT / GTEQ / GT ) BINOP_P05 )*
BINOP_P05      <- { BINOP_P04 } ( ( LSHIFT / RSHIFT ) BINOP_P04 )*
BINOP_P04      <- { BINOP_P03 } ( ( ADD / SUB ) BINOP_P03 )*
BINOP_P03      <- { UNARIES }   ( ( MUL / DIV / POW ) UNARIES )*

UNARIES        <- { UNARY }* { TERM }
UNARY          <- { NOT / INC / DEC }
TERM           <- { LITERAL } /
                  { FUNCTIONCALL } /
                  { REFERENCE } /
                  { BOPEN { EXPRESSION } BCLOSE }

FUNCTIONCALL   <- { REFERENCE }
                  BOPEN ( EXPRESSION ( COMMA EXPRESSION )* )? BCLOSE

REFERENCE      <- IDENT ( DOT IDENT )* INDEX*
INDEX          <- ABOPEN { EXPRESSION } ABCLOSE

LITERAL        <- STRINGLITERAL /
                  HASHLITERAL /
                  LISTLITERAL /
                  FLOATLITERAL /
                  INTLITERAL /
                  BOOLEANLITERAL

STRINGLITERAL  <- '\'' { ( '\\' ([nrtv\\'] / [0-9]^3) / [^'\\] )* } '\''
HASHLITERAL    <- { CBOPEN ( HASHELT ( COMMA HASHELT )* )? CBCLOSE }
HASHELT        <- { HASHKEY COLON HASHVALUE }
HASHKEY        <- { TERM }
HASHVALUE      <- { TERM }
LISTLITERAL    <- { ABOPEN ( LISTELT ( COMMA LISTELT )* )? ABCLOSE }
LISTELT        <- { TERM }
FLOATLITERAL   <- { [0-9]* '.' [0-9]+ }
INTLITERAL     <- { [0-9]+ }
BOOLEANLITERAL <- { 'true' / 'false' }

KW_IMPORT      <- 'import'
KW_FUNCTION    <- 'function'
KW_VAR         <- 'var'
KW_WHILE       <- 'while'
KW_RETURN      <- 'return'
KW_IF          <- 'if'
KW_ELSEIF      <- 'elseif'
KW_ELSE        <- 'else'
KW_BREAK       <- 'break'
KW_CONTINUE    <- 'continue'

IDENT          <- { [a-zA-Z_][a-zA-Z0-9_]^0-63 }
BOPEN          <- '('
BCLOSE         <- ')'
CBOPEN         <- '{'
CBCLOSE        <- '}'
ABOPEN         <- '['
ABCLOSE        <- ']'
ASSIGNS        <- { ASSIGN / PLUSIS / MINIS / MULIS / DIVIS /
                    BITANDIS / BITORIS / BITXORIS /
                    LSHIFTIS / RSHIFTIS }
ASSIGN         <- { '=' }
PLUSIS         <- { '+=' }
MINIS          <- { '-=' }
MULIS          <- { '*=' }
DIVIS          <- { '/=' }
EQUALS         <- { '==' }
NEQUALS        <- { '!=' }
LT             <- { '<' !'=' }
GT             <- { '>' !'=' }
LTEQ           <- { '<=' }
GTEQ           <- { '>=' }
SEMICOLON      <- ';'
COLON          <- { ':' }
POW            <- { '**' }
MUL            <- { '*' !'*' }
DIV            <- { '/' !'=' }
ADD            <- { '+' ![+=] }
SUB            <- { '-' ![\-=] }
INC            <- { '++' }
DEC            <- { '--' }
AND            <- { '&&' }
OR             <- { '||' }
BITAND         <- { '&' ![&=] }
BITOR          <- { '|' ![|=] }
BITXOR         <- { '^' !'=' }
BITANDIS       <- { '&=' }
BITORIS        <- { '|=' }
BITXORIS       <- { '^=' }
NOT            <- { '!' !'=' }
COMMA          <- { ',' }
DOT            <- { '.' }
LSHIFT         <- { '<<' ! '=' }
RSHIFT         <- { '>>' ! '=' }
LSHIFT         <- { '<<=' }
RSHIFT         <- { '>>=' }
