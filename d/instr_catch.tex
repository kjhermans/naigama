\subsection{Instruction: catch}

\subsubsection{Summary}

The 'catch' instruction pushes a 'catch' element on the stack,
in which the current state of the engine is captured (input position,
height of the action list), as well as a bytecode offset, which
is where the engine jumps to when the element is popped due to a FAIL
condition.

\subsubsection{Grammar and Compiling}

Several constructs in the Naigama grammar emit a 'catch' instruction,
for example:

\begin{itemize}

\item A 'choice' situation, which is when an OR operator ('/', or
slash forward) is introduced in an expression.

\item A 'not' situation, which is when a matcher is prefixed with a NOT
operator ('!', or exclamation mark).

\item A 'not-not' situation, which is when a matcher is prefixed with an
ampersand ('\&').

\item A quantifier on a matcher that is forgiving, for example allowing
infinite repetitions of a matcher, or values between a minimum and a
maximum.

\end{itemize}

\subsubsection{Assembly Syntax}

\begin{myquote}
\begin{verbatim}
CATCHINSTR <- 'catch' S LABEL
S          <- %s+
LABEL      <- [a-zA-Z0-9_]^1-64

\end{verbatim}
\end{myquote}

\subsubsection{Bytecode Encoding}

This instruction is structured in bytecode as follows:

%DEADBEEF
$_0$\ 
\fbox{%
  \parbox{20pt}{%
00
  }%
}
\fbox{%
  \parbox{20pt}{%
04
  }%
}
\fbox{%
  \parbox{20pt}{%
0a
  }%
}
\fbox{%
  \parbox{20pt}{%
03
  }%
}

%DEADBEEF

$_4$\
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}

Where 'nn' is a 32-bit, network encoded, valid bytecode offset.

\subsubsection{Execution State Change}

.

Original state: \textit{(p, i, e, c)}

Operation: \textbf{catch n}

Failure state: -

Success state: \textit{(p + 1, i, e:(n,p,i), c)}

