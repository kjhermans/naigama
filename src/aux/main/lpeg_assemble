#!/usr/bin/perl

##
##
##  Tool that generates bytecode from LPEG assembly
##
##  Usage: $0 (inputfile / '-') (outputfile / '-')
##
##
##

##DEADBEEF
my $INSTR_ANY = 1283;
my $INSTR_BACKCOMMIT = 264752;
my $INSTR_CALL = 262915;
my $INSTR_CATCH = 264707;
my $INSTR_CHAR = 263433;
my $INSTR_CLOSECAPTURE = 528133;
my $INSTR_COMMIT = 264709;
my $INSTR_CONDJUMP = 525107;
my $INSTR_COUNTER = 525071;
my $INSTR_END = 262922;
my $INSTR_FAIL = 2570;
my $INSTR_FAILTWICE = 2575;
my $INSTR_JUMP = 262921;
my $INSTR_MASKEDCHAR = 263434;
my $INSTR_NOOP = 0;
my $INSTR_OPENCAPTURE = 265987;
my $INSTR_PARTIALCOMMIT = 264713;
my $INSTR_QUAD = 263475;
my $INSTR_RANGE = 525651;
my $INSTR_REPLACE = 265994;
my $INSTR_REPLACESTRING = 265999;
my $INSTR_RET = 773;
my $INSTR_SET = 2098489;
my $INSTR_SKIP = 263509;
my $INSTR_SKIPVAR = 264531;
my $INSTR_SPAN = 2098495;
my $INSTR_TESTANY = 263429;
my $INSTR_TESTCHAR = 525583;
my $INSTR_TESTQUAD = 525621;
my $INSTR_TESTSET = 2360634;
my $INSTR_VAR = 265993;
my $dbghsh = {
  1283 => 'ANY',
  264752 => 'BACKCOMMIT',
  262915 => 'CALL',
  264707 => 'CATCH',
  263433 => 'CHAR',
  528133 => 'CLOSECAPTURE',
  264709 => 'COMMIT',
  525107 => 'CONDJUMP',
  525071 => 'COUNTER',
  262922 => 'END',
  2570 => 'FAIL',
  2575 => 'FAILTWICE',
  262921 => 'JUMP',
  263434 => 'MASKEDCHAR',
  0 => 'NOOP',
  265987 => 'OPENCAPTURE',
  264713 => 'PARTIALCOMMIT',
  263475 => 'QUAD',
  525651 => 'RANGE',
  265994 => 'REPLACE',
  265999 => 'REPLACESTRING',
  773 => 'RET',
  2098489 => 'SET',
  263509 => 'SKIP',
  264531 => 'SKIPVAR',
  2098495 => 'SPAN',
  263429 => 'TESTANY',
  525583 => 'TESTCHAR',
  525621 => 'TESTQUAD',
  2360634 => 'TESTSET',
  265993 => 'VAR',
};
##DEADBEEF

use Data::Dumper;

my $inputfile = shift @ARGV;
my $outputfile = shift @ARGV;

my ($in, $out);

if ($inputfile eq '-') {
  $in = \STDIN;
} else {
  open $in, '<', $inputfile || die "Could not open $inputfile";
}

if ($outputfile eq '-') {
  $out = \STDOUT;
} else {
  open $out, '>', $outputfile || die "Could not open $outputfile";
}

my @input;
{
  while (my $line = <$in>) {
    push @input, { line => $line };
  }
  close $in;
}

my %labelmap;

shift @input;

first_pass(@input);
second_pass(@input);

close($out);

exit 0;

1;

sub first_pass
{
  my @lines = @_;
  my $address = 0;
  foreach my $line (@lines) {
    if ($line->{line} =~ s/^([0-9]+)://) {
      $labelmap{int($1)} = $address;
    } else {
#      die "LPEG ASM instruction '$line->{line}' not prepended with a number";
      next;
    }
    $line->{line} =~ s/^\s+//;
    $line->{line} =~ s/\s+$//;
    if ($line->{line} =~ /^\s*any$/) {
      $address += 4;
    } elsif ($line->{line} =~ /^\s*testany\s+/) {
      $address += 8;
    } elsif ($line->{line} =~ /^\s*char\s+/) {
      $address += 8;
    } elsif ($line->{line} =~ /^\s*testchar\s+/) {
      $address += 12;
    } elsif ($line->{line} =~ /^\s*set\s+/) {
      $address += 36;
    } elsif ($line->{line} =~ /^\s*testset\s+/) {
      $address += 40;
    } elsif ($line->{line} =~ /^\s*span\s+/) {
      $address += 36;
    } elsif ($line->{line} =~ /^\s*choice\s+/) {
      $address += 8;
    } elsif ($line->{line} =~ /^\s*commit\s+/) {
      $address += 8;
    } elsif ($line->{line} =~ /^\s*partial_commit\s+/) {
      $address += 8;
    } elsif ($line->{line} =~ /^\s*fail$/) {
      $address += 4;
    } elsif ($line->{line} =~ /^\s*failtwice$/) {
      $address += 4;
    } elsif ($line->{line} =~ /^\s*jmp\s+/) {
      $address += 8;
    } elsif ($line->{line} =~ /^\s*call\s+/) {
      $address += 8;
    } elsif ($line->{line} =~ /^\s*ret$/) {
      $address += 4;
    } elsif ($line->{line} =~ /^\s*end$/) {
      $address += 8;
    } elsif ($line->{line} =~ /^\s*fullcapture\s+/) {
      ## not implemented yet
    } elsif ($line->{line} =~ /^\s*opencapture\s+/) {
      ## not implemented yet
    } elsif ($line->{line} =~ /^\s*closecapture$/) {
      ## not implemented yet
    } elsif ($line->{line} =~ /^\s*closeruntime$/) {
      ## not implemented yet
    } elsif ($line->{line} =~ /^--/) {
      $address += 4;
    } else {
      die "Unknown opcode $line->{line}";
    }
  }
}

sub second_pass
{
  my @lines = @_;
  my $address = 0;
  my $char = "[a-f0-9A-F]{2}";
  my $label = "[a-zA-Z0-9_]+";
  foreach my $line (@lines) {
    $line =~ s/^[0-9]+:\s*//;
    if ($line->{line} =~ /^\s*any$/) {
      syswrite($out, pack('N', $INSTR_ANY));
    } elsif ($line->{line} =~ /^\s*testany\s*->\s*($label)$/) {
      my $address = $labelmap{$1};
      die "Unmapped jump" if (!defined($address));
      syswrite($out, pack('N', $INSTR_TESTANY));
      syswrite($out, pack('N', $address));
    } elsif ($line->{line} =~ /^\s*char\s*'.'\s*\(($char)\)$/) {
      my $c = hex($1);
      syswrite($out, pack('N', $INSTR_CHAR));
      syswrite($out, pack('N', $c));
    } elsif ($line->{line} =~ /^\s*testchar.*\(($char)\)\s*->\s*([0-9]+)$/) {
      my ($h, $n) = ($1, $2);
      my ($c, $address) = (hex($h), $labelmap{$n});
      die "Unmapped jump to $n" if (!defined($address));
      syswrite($out, pack('N', $INSTR_TESTCHAR));
      syswrite($out, pack('N', $address));
      syswrite($out, pack('N', $c));
    } elsif ($line->{line} =~ /^\s*set\s*(\[.*$)/) {
      my $s = range_string({ range => { set => parse_range($1) } });
      syswrite($out, pack('N', $INSTR_SET));
      while (length($s)) {
        $s =~ s/^(.{8})//;
        my $h = hex($1);
        syswrite($out, pack('N', $h));
      }
    } elsif ($line->{line} =~ /^\s*testset\s*(\[.*\])\s*->\s*([0-9]+)$/) {
      my $address = $labelmap{$2};
      my $s = range_string({ range => { set => parse_range($1) } });
      die "Unmapped jump" if (!defined($address));
      syswrite($out, pack('N', $INSTR_TESTSET));
      syswrite($out, pack('N', $address));
      while (length($s)) {
        $s =~ s/^(.{8})//;
        my $h = hex($1);
        syswrite($out, pack('N', $h));
      }
    } elsif ($line->{line} =~ /^\s*span\s*(\[.*$)/) {
      my $s = range_string({ range => { set => parse_range($1) } });
      syswrite($out, pack('N', $INSTR_SPAN));
      while (length($s)) {
        $s =~ s/^(.{8})//;
        my $h = hex($1);
        syswrite($out, pack('N', $h));
      }
    } elsif ($line->{line} =~ /^\s*choice\s*->\s*([0-9]+)$/) {
      my $address = $labelmap{$1};
      die "Unmapped jump" if (!defined($address));
      syswrite($out, pack('N', $INSTR_CATCH));
      syswrite($out, pack('N', $address));
    } elsif ($line->{line} =~ /^\s*commit\s*->\s*([0-9]+)$/) {
      my $address = $labelmap{$1};
      die "Unmapped jump" if (!defined($address));
      syswrite($out, pack('N', $INSTR_COMMIT));
      syswrite($out, pack('N', $address));
    } elsif ($line->{line} =~ /^\s*partial_commit\s*->\s*([0-9]+)$/) {
      my $address = $labelmap{$1};
      die "Unmapped jump" if (!defined($address));
      syswrite($out, pack('N', $INSTR_PARTIALCOMMIT));
      syswrite($out, pack('N', $address));
    } elsif ($line->{line} =~ /^\s*fail$/) {
      syswrite($out, pack('N', $INSTR_FAIL));
    } elsif ($line->{line} =~ /^\s*failtwice$/) {
      syswrite($out, pack('N', $INSTR_FAILTWICE));
    } elsif ($line->{line} =~ /^\s*jmp\s*->\s*([0-9]+)/) {
      my $address = $labelmap{$1};
      die "Unmapped jump" if (!defined($address));
      syswrite($out, pack('N', $INSTR_JUMP));
      syswrite($out, pack('N', $address));
    } elsif ($line->{line} =~ /^\s*call\s*->\s*([0-9]+)/) {
      my $address = $labelmap{$1};
      die "Unmapped jump" if (!defined($address));
      syswrite($out, pack('N', $INSTR_CALL));
      syswrite($out, pack('N', $address));
    } elsif ($line->{line} =~ /^\s*ret$/) {
      syswrite($out, pack('N', $INSTR_RET));
    } elsif ($line->{line} =~ /^\s*end$/) {
      syswrite($out, pack('N', $INSTR_END));
      syswrite($out, pack('N', 0));
    } elsif ($line->{line} =~ /^\s*fullcapture\s+([a-z]+)/) {
      ## not implemented yet
    } elsif ($line->{line} =~ /^\s*opencapture\s+([a-z]+)/) {
      ## not implemented yet
    } elsif ($line->{line} =~ /^\s*closecapture$/) {
      ## not implemented yet
    } elsif ($line->{line} =~ /^\s*closeruntime$/) {
      ## not implemented yet
    } elsif ($line->{line} =~ /^nil$/) {
      ## ignore
    } elsif ($line->{line} =~ /^--$/) {
      syswrite($out, pack('N', 0));
    } else {
      $line->{line} =~ s/^\s+//;
      $line->{line} =~ s/\s+$//;
      die "Unknown LPEG instruction '$line->{line}'" if (length($line->{line}));
    }
  }
}

sub parse_range
{
  my $line = shift;
  my $result = [];
#  return undef if ($line !~ /\[([()0-9a-f]+)\]/);
  return undef if ($line !~ /\[(.+)\]/);
  my $set = $1;
  while (length($set)) {
    if ($set =~ s/\(([0-9a-f]{2})\)//i) {
      push @{$result}, [ hex($1) ];
    } elsif ($set =~ s/\(([0-9a-f]{2})-([0-9a-f]{2})\)//i) {
      push @{$result}, [ hex($1), hex($2) ];
    } else {
      return undef;
    }
  }
  return $result;
}

sub range_string {
  my $token = shift;
  my @mask = (
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  );
  if ($token->{range}{negative}) {
     @mask = (
      255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255
    );
  }
  foreach my $elt (@{$token->{range}{set}}) {
    if (scalar(@{$elt}) == 1) {
      if ($token->{range}{negative}) {
        $mask[ $elt->[ 0 ] / 8 ] &= ~(1 << ($elt->[ 0 ] % 8));
      } else {
        $mask[ $elt->[ 0 ] / 8 ] |= (1 << ($elt->[ 0 ] % 8));
      }
    } elsif (scalar(@{$elt}) == 2) {
      foreach ($elt->[0] .. $elt->[1]) {
        if ($token->{range}{negative}) {
          $mask[ $_ / 8 ] &= ~(1 << ($_ % 8));
        } else {
          $mask[ $_ / 8 ] |= (1 << ($_ % 8));
        }
      }
    }
  }
  return join('', map(sprintf("%.2x", $_), @mask));
}
