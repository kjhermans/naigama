#!/usr/bin/perl

##
## Compiles snort rules
##

use Data::Dumper;
use IPEG;

my $inputfile = shift @ARGV || die "Need input file";
my $outputfile = shift @ARGV || "-";

my ($in, $out);

if ($inputfile eq '-') {
  $in = *STDIN;
} else {
  open $in, '<', $inputfile || die "Could not open $inputfile";
  print STDERR "Successfully opened $inputfile.\n";
}

if ($outputfile eq '-') {
  $out = *STDOUT;
} else {
  open $out, '>', $outputfile || die "Could not open $outputfile";
}

my @input;
{
  while (my $line = <$in>) {
    push @input, $line;
  }
  close $in;
}

my $rulegrammar = q(

snortrule  <- {action} sp+ {protocol} sp+ {expression} sp* {options}
action     <- 'alert'    /
              'log'      /
              'pass'     /
              'activate' /
              'dynamic'
protocol   <- 'tcp'      /
              'udp'      /
              'icmp'
expression <- {fromip} sp+ {fromport} sp* {operator} sp* {toip} sp+ {toport}
fromip     <- ipdef / 'any'
toip       <- ipdef / 'any'
ipdef      <- { '!'? } sp* ip
ip         <- ipadrorseg / iplist
ipadrorseg <- ipseg / { ipadr }
ipseg      <- { ipadr } '/' { [0-9]+ }
ipadr      <- [0-9]+ '.' [0-9]+ '.' [0-9]+ '.' [0-9]+
iplist     <- '[' sp* { ipadrorseg } ( sp* ',' sp* { ipadrorseg } )* sp* ']'
fromport   <- port
toport     <- port
port       <- [0-9]+ / 'any'
operator   <- '->' /
              '<-' /
              '<->'
options    <- nvlist / ...
nvlist     <- '(' sp* namevalue ( sp* ';' sp* namevalue )* sp* ';'? ')'
namevalue  <- { name } sp* ':' sp* { value }
name       <- [a-zA-Z]+
value      <- '"' [^"]* '"'
sp         <- [ \t]

);

my $slots = {
  0 => 'action',
  1 => 'protocol',
  2 => 'expression',
  3 => 'options',
  4 => 'fromip',
  5 => 'fromport',
  6 => 'operator',
  7 => 'toip',
  8 => 'toport',
  9 => 'not',
  10 => 'ipaddr',
  11 => 'ipsegaddr',
  12 => 'ipsegbits',
  13 => 'listip',
  14 => 'nextlistip',
  15 => 'name',
  16 => 'value',
};

my $ipeg = IPEG->new($rulegrammar);
#print $ipeg->{assembly};
#$ipeg->{engine}->set_debug(1);
#$ipeg->{engine}->set_labelmap( $ipeg->{assembler}->get_labelmap() );

my @rules;
my @assembly;
print STDERR scalar(@input) . " lines of input.\n";
for (my $i=0; $i < scalar(@input); $i++) {
  my $rule = $input[ $i ];
  print STDERR "Processing rule: $rule\n";
  $rule =~ s/^\s+//;
  my $match = $ipeg->match($rule);
  if (!defined($match) || $match->{endcode} ne '0') {
    die "Rule parsing error in $rule";
  }
  my $rs = { leftside => {} };
  my $ipside = $rs->{leftside};
  my $curip;
  foreach my $capture (@{$match->{captures}}) {
    my $type = $slots->{$capture->{slot}};
    #print STDERR "$capture->{slot}: $type $capture->{string}\n";
    if ($type eq 'action') {
      $rs->{action} = $capture->{string};

    } elsif ($type eq 'protocol') {
      $rs->{protocol} = $capture->{string};

    } elsif ($type eq 'fromport') {
      $rs->{leftside}{port} = $capture->{string};

    } elsif ($type eq 'toport') {
      $rs->{rightside}{port} = $capture->{string};

    } elsif ($type eq 'not' && $capture->{string} eq '!') {
      $ipside->{not} = 1;

    } elsif ($type eq 'ipsegaddr') {
      push @{$ipside->{ips}}, { ipsegaddr => $capture->{string} };
      $curip = $ipside->{ips}->[ -1 ];

    } elsif ($type eq 'ipsegbits') {
      $curip->{ipsegbits} = $capture->{string};

    } elsif ($type eq 'operator') {
      $rs->{operator} = $capture->{string};
      $rs->{rightside} = {};
      $ipside = $rs->{rightside};

    } else {
    }
  }
  my $instr = compile_rule($rs, $i);
  push @assembly, @{$instr};
}
print $out join("\n", @assembly) . "\n";

exit 0;

sub compile_rule
{
  my $rule = shift;
  my $index = shift;

  my $result = [
    "  catch RULE_$index" . '_OUT',
    '  skip 12',
    '  char 08',
    '  char 00',
    '  bits 40 f0',
    '  skip 9',
  ]; 
  if ($rule->{protocol} eq 'tcp') {
    push @{$result}, '  char 06';
  } elsif ($rule->{protocol} eq 'icmp') {
    push @{$result}, '  char 01';
  } elsif ($rule->{protocol} eq 'udp') {
    push @{$result}, '  char 11';
  } else {
    die "Unknown protocol specification in rule $index";
  }
  push @{$result}, '  skip 3';
  push @{$result}, compile_ip($rule->{leftside}{ips});
  push @{$result}, compile_ip($rule->{rightside}{ips});
##..
  push @{$result},
    "  end $index",
    "RULE_$index" . '_OUT:';
  return $result;
}

sub compile_ip
{
  my $iplist = shift;
  my @result;
  foreach my $ip (@{$iplist}) {
    if ($ip->{any}) {
      return ( '  skip 4' );
    }
  }
  return @result;
}

1;
