#!/usr/bin/perl

my $inputfile = shift @ARGV;
my $outputfile = shift @ARGV;

if (!defined($inputfile)) {
  die "Need bytecode input file";
}
if (!defined($outputfile)) {
  $outputfile = '-';
}

my ($in, $out);

if ($inputfile eq '-') {
  $in = *STDIN;
} else {
  open $in, '<', $inputfile || die "Could not open $inputfile";
}

if (!defined($outputfile)) {
  $outputfile = '-';
}
if ($outputfile eq '-') {
  $out = *STDOUT;
} else {
  open $out, '>', $outputfile || die "Could not open $outputfile";
}

my $definitions = eval( `cat $inputfile` );
my $cc = 0;

print $out
"#include <stdio.h>\n\n" .
  "#include <string.h>\n\n" .
  "#include <ipeg_parser.h>\n" .
  "\n";

my $prefix = 0;

foreach my $rule (@{$definitions}) {
  print $out "static int rule_$rule->{ident}\n" .
             "  (struct ipeg_parser* parser);\n" .
             "\n";
  if ($rule->{ident} eq '__prefix') {
    $prefix = 1;
  }
}

print $out "
int ipeg_parse
  (
    unsigned char* data,       /* Oblig: data to be parsed */
    unsigned size,             /* Oblig: size of the the data to be parsed */
    void* capmem,              /* Maybenull: memory used for capture */
    unsigned capmemlen,        /* Maybezero: size of memory used for capture */
    ipeg_capture_t** capture   /* Maybenull: captures linked list */
  )
{
  struct ipeg_parser p;

  memset(&p, 0, sizeof(p));
  p.data.buffer = data;
  p.data.length = size;
  p.capture.buffer = capmem;
  p.capture.length = capmemlen;
  if (capmemlen > sizeof(ipeg_capture_t)) {
    *capture = (ipeg_capture_t*)capmem;
  }
  return rule_" . $definitions->[0]{ident} . "(&p);
}

";

foreach my $rule (@{$definitions}) {
  my $catch = uc($rule->{ident}) . "_FINAL";
  print $out "static int rule_$rule->{ident}\n" .
             "  (struct ipeg_parser* parser)\n" .
             "{\n";
  if ($prefix && $rule->{ident} ne '__prefix') {
    print $out "  if (rule___prefix(parser)) { goto $catch; }\n";
  }
  print $out output_tokens($rule->{tokens}, $rule, $catch, 0);
  print $out "  return 0;\n" .
             "$catch:\n" .
             "  __attribute__((unused))\n" .
             "  return -1;\n" .
             "}\n\n";
}

sub output_tokens
{
  my $tokens = shift;
  my $rule = shift;
  my $catch = shift;
  my $indent = shift || 0;
  my $istr = ' ' x (($indent + 1) * 2);
  my $result = '';
  my $not = 0;
TOKEN:
  foreach my $token(@{$tokens}) {
    $result .=
      '/* ' . $token->{text} . " */\n";
    if ($token->{type} eq 'catch') {
      ++$cc;
      my $alt = uc($rule->{ident}) . "_CATCH_$cc";
      my $out = uc($rule->{ident}) . "_OUT_$cc";
      $result .=
        output_tokens($token->{lefthand}, $rule, $alt, $indent) .
        $istr . "goto $out;\n" .
        $alt . ": ;\n" .
        output_tokens($token->{righthand}, $rule, $catch, $indent) .
        $out . ":\n" .
        "  __attribute__((unused))\n" .
        "  ;\n";
    } elsif ($token->{type} eq 'ident') {
      $result .= output_matching_token($token, $not, $catch, 'ident');
    } elsif ($token->{type} eq 'groupopen') {
      $result .= output_matching_token($token, $not, $catch, 'group');
    } elsif ($token->{type} eq 'range') {
      $result .= output_matching_token($token, $not, $catch, 'range');
    } elsif ($token->{type} eq 'not') {
      $not = 1;
      next TOKEN;
    } elsif ($token->{type} eq 'any') {
      $result .= output_matching_token($token, $not, $catch, 'any');
    } elsif ($token->{type} eq 'string') {
      $result .= output_matching_token($token, $not, $catch, 'string');
#    } elsif ($token->{type} eq 'macro') {
#      rework_macro($token);
#      $result .= output_matching_token($token, $not, $catch, 'range');
    } elsif ($token->{type} eq 'opencapture') {
      $result .= output_matching_token($token, $not, $catch, 'group');
    } elsif ($token->{type} eq 'openvarcapture') {
      $result .= output_matching_token($token, $not, $catch, 'group');
    } elsif ($token->{type} eq 'varreference') {
    } elsif ($token->{type} eq 'closecapture') {
    } elsif ($token->{type} eq 'replace') {
    }
    $not = 0;
  }
  return $result;
}

sub output_matching_token
{
  my ($token, $not, $catch, $callback) = @_;
  my $prefunctor = "pre_output_$callback";
  my $functor = "output_$callback";
  my $result = eval { &$prefunctor($token, $not, $catch); } || "";
  if ($token->{quantifier}{min} == 1
      && $token->{quantifier}{max} == 1)
  {
    return $result . &$functor($token, $not, $catch);
  }
  $result .=
    "  { int i; (void)i; fprintf(stderr, \"$callback $catch \%u\\n\", parser->data.offset); \n";
  if ($token->{quantifier}{min} > 0) {
    $result .=
      "    for (i=0; i < $token->{quantifier}{min}; i++) {\n" .
      &$functor($token, $not, $catch) .
      "    }\n";
  }
  if (defined($token->{quantifier}{max})) {
    if ($token->{quantifier}{max} > $token->{quantifier}{min}) {
      my $n = ++$cc;
      my $out = $catch . "_OUT_$n";
      $result .=
        "    for (i=0; i < " .
        ($token->{quantifier}{max} - $token->{quantifier}{min}) .
        "; i++) {\n" .
        &$functor($token, $not, $out) .
        "    }\n" .
        "$out:\n" .
        "  __attribute__((unused))\n" .
        "  ;\n";
    }
  } else {
    my $n = ++$cc;
    my $out = $catch . "_OUT_$n";
    $result .=
      "     while (1) {\n" .
      &$functor($token, $not, $out) .
      "    }\n" .
      "$out:\n" .
      "  __attribute__((unused))\n" .
      "  ;\n";
  }
  $result .=
    "  }\n";
  return $result;
}

sub output_group
{
  my ($token, $not, $catch) = @_;
  ++$cc;
  my $notcatch = "NOT_$cc";
  if ($not) {
    return
      output_tokens($token->{group}, $rule, $notcatch, $indent) .
      "fprintf(stderr, \"goto $catch\\n\");\n" .
      "  goto $catch;\n" .
      "$notcatch:\n" .
      "  __attribute__((unused))\n" .
      "  ;\n";
  } else {
    return
      output_tokens($token->{group}, $rule, $catch, $indent);
  }
}

sub output_ident
{
  my ($token, $not, $catch) = @_;
  if ($not) {
    return "  if (0 == rule_$token->{ident}(parser)) {\n" .
           "fprintf(stderr, \"goto $catch\\n\");\n" .
           "    goto $catch;\n" .
           "  }\n";
  } else {
    return "  if (rule_$token->{ident}(parser)) {\n" .
           "fprintf(stderr, \"goto $catch\\n\");\n" .
           "    goto $catch;\n" .
           "  }\n";
  }
}

sub output_any
{
  my ($token, $not, $catch) = @_;
  my $result = '';
  if ($not) {
    $result .=
      "  if (parser->data.offset < parser->data.length) {\n" .
      "fprintf(stderr, \"goto $catch\\n\");\n" .
      "    goto $catch;\n" .
      "  }\n";
  } else {
    $result .=
      "  if (parser->data.offset >= parser->data.length) {\n" .
      "fprintf(stderr, \"goto $catch\\n\");\n" .
      "    goto $catch;\n" .
      "  }\n";
  }
  $result .=
    "  ++(parser->data.offset);\n";
  return $result;
}

#sub rework_macro
#{
#  my ($token) = @_;
#  if ($token->{macro} eq 's') {
#    $token->{range}{set} = [ [ 8 ], [ 10 ], [ 13 ], [ 32 ] ];
#  } elsif ($token->{macro} eq 'w') {
#    $token->{range}{set} = [ [ 65, 90 ], [ 97, 122 ] ];
#  } elsif ($token->{macro} eq 'nl') {
#    $token->{range}{set} = [ [ 10 ], [ 13 ] ];
#  }
#}

sub pre_output_range
{
  my ($token, $not, $catch) = @_;
  ++$cc;
  my $result =
    "  unsigned char range_$cc" . "[] = {\n" .
    "    " . range_string($token) .
    "  };\n" .
    "#undef CURRENT_RANGE\n" .
    "#define CURRENT_RANGE range_$cc\n";
  return $result;
}

sub output_range
{
  my ($token, $not, $catch) = @_;
  my $result =
    output_any($token, $not, $catch) .
    "  {\n" .
    "    unsigned char c = parser->data.buffer[ parser->data.offset ];\n";
  if ($not) {
    $result .=
      "    if ((";
  } else {
    $result .=
      "    if (!(";
  }
  $result .=
    "CURRENT_RANGE[ c / 8 ] & (1 << (c % 8)))) {\n" .
    "fprintf(stderr, \"goto $catch\\n\");\n" .
    "    goto $catch;\n" .
    "  }\n" .
    "  ++(parser->data.offset);\n" .
    "}\n";
  return $result;
}

sub pre_output_string
{
  my ($token, $not, $catch) = @_;
  ++$cc;
  my $result =
    "  {\n" .
    "    unsigned char cmp_$cc" . "[] = {\n";
  for (my $i=0; $i < length($token->{string}); $i++) {
    $result .=
      "      0x".sprintf("%.2x", ord(substr($token->{string}, $i, 1))) .
      (($i < length($token->{string})-1) ? ",\n" : "\n");
  }
  $result .=
    "    };\n" .
    "#undef CURRENT_STRING\n" .
    "#define CURRENT_STRING cmp_$cc\n";
  return $result;
}

sub output_string
{
  my ($token, $not, $catch) = @_;
  my $result =
    "    if (parser->data.offset > parser->data.length - " .
    "sizeof(CURRENT_STRING)) {\n" .
    "fprintf(stderr, \"goto $catch\\n\");\n" .
    "      goto $catch;\n" .
    "    }\n" .
    "    if (memcmp(\n" .
    "          parser->data.buffer + parser->data.offset,\n" .
    "          CURRENT_STRING,\n" .
    "          sizeof(CURRENT_STRING))) {\n" .
    "fprintf(stderr, \"goto $catch\\n\");\n" .
    "      goto $catch;\n" .
    "    }\n" .
    "    (parser->data.offset) += sizeof(CURRENT_STRING);\n" .
    "  }\n";
  return $result;
}

sub range_string {
  my $token = shift;
  my @mask = (
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  );
  if ($token->{range}{negative}) {
     @mask = (
      255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255,
      255, 255, 255, 255, 255, 255, 255, 255
    );
  }
  foreach my $elt (@{$token->{range}{set}}) {
    if (scalar(@{$elt}) == 1) {
      if ($token->{range}{negative}) {
        $mask[ $elt->[ 0 ] / 8 ] &= ~(1 << ($elt->[ 0 ] % 8));
      } else {
        $mask[ $elt->[ 0 ] / 8 ] |= (1 << ($elt->[ 0 ] % 8));
      }
    } elsif (scalar(@{$elt}) == 2) {
      foreach ($elt->[0] .. $elt->[1]) {
        if ($token->{range}{negative}) {
          $mask[ $_ / 8 ] &= ~(1 << ($_ % 8));
        } else {
          $mask[ $_ / 8 ] |= (1 << ($_ % 8));
        }
      }
    }
  }
  return '0x' . join(",\n    0x", map(sprintf("%.2x", $_), @mask));
}

1;
