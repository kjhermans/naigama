\subsection{Instruction: closecapture}

\subsubsection{Summary}

\subsubsection{Grammar and Compiling}

\subsubsection{Assembly Syntax}

\begin{myquote}
\begin{verbatim}
CLOSECAPTUREINSTR <- 'closecapture' S SLOT (S TYPE)?
S                 <- %s+
SLOT              <- [0-9]+
TYPE              <- [0-9]+

\end{verbatim}
\end{myquote}

\subsubsection{Bytecode Encoding}

This instruction is structured in bytecode as follows:

%DEADBEEF
$_0$\ 
\fbox{%
  \parbox{20pt}{%
00
  }%
}
\fbox{%
  \parbox{20pt}{%
08
  }%
}
\fbox{%
  \parbox{20pt}{%
0f
  }%
}
\fbox{%
  \parbox{20pt}{%
05
  }%
}

%DEADBEEF

$_4$\
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}

$_8$\
\fbox{%
  \parbox{20pt}{%
mm
  }%
}
\fbox{%
  \parbox{20pt}{%
mm
  }%
}
\fbox{%
  \parbox{20pt}{%
mm
  }%
}
\fbox{%
  \parbox{20pt}{%
mm
  }%
}

\subsubsection{Execution State Change}

.

Original state: \textit{(p, i, e, c)}

Operation: \textbf{any} ; i \ \textless \ $\vert$S$\vert$

Failure state: \textit{(\textbf{Fail}, i, e, c)}

Success state: \textit{(p + 1, i + 1, e, c)}

