\section{Engine}
\label{sec:engine}

The Naigama bytecode execution engine or library can be used to
match or fail an input of data using a bytecode.
Both bytecode and input are defined as a buffer of memory with
a certain length. The bytecode buffer may be the result of
the Naigama assembly process; the input is arbitrary data.

\subsection{Order of Execution}

Execution will start with the engine setting the current bytecode
offset to zero.

The engine will execute the instruction at the current bytecode
offset, and then either jump
to another offset within the bytecode if this is the result of
the instruction execution, or to the next instruction, which is
located at the current bytecode offset, plus the size of the
instruction. Bear in mind that instructions have different sizes;
the size of the instruction is a function of the opcode.
This is specified in table [\ref{tab:naig_bytecode}].

Execution ends when an abnormal state is encountered, the FAIL
condition extinguishes the entire stack, or the 'end' instruction
is encountered.

\subsection{Execution States}

The engine must at least provision the following state during execution
of the bytecode buffer.

\subsubsection{Bytecode Offset}

The bytecode offset is an offset in the bytecode. Its value is
between zero (inclusive) and the length of the bytecode (exclusive)
minus four, and is always a multiple of four.

\subsubsection{Input Position}

The input position is the position in the input buffer. Its value
is between zero (inclusive) and the length of the input buffer (exclusive).

\subsubsection{Stack}

The stack is a Last-in-first-out list of items. There are two types
of items that can be on the stack, and there are two instructions that
push each of these items:

\begin{itemize}

\item A 'call' instruction makes the engine jump to a certain address,
but it also pushes a return address on the stack
(this is the address of the instruction following the 'call' instruction),
so that when a 'ret' instruction is encountered,
and this item is popped from the stack, the engine knows where to continue.

Alternatively, a FAIL condition may pop these items from the stack as well.

\item A 'catch' instruction pushes an item on the stack which saves the
engine's state at that point, and contains an alternative address to jump
to. The engine's state is represented by the bytecode offset, the input
position, and the length of the action list.

These items are removed by their corresponding 'commit' instructions however,
a FAIL condition in this case pops the stack item, but then restores the
engine's state and jumps to the alternative address.

\end{itemize}

\subsubsection{Action List}

The action list contains actions related to capturing from the input buffer.
It may contain the following type items:

\begin{itemize}

\item A 'opencapture' type element, which contains an input position
      and a slot number.
\item A 'closecapture' type element, which contains an input position
      and a slot number.
\item A 'replace' type element, which contains two offsets.

\end{itemize}

\subsubsection{Register}

\subsection{Special Conditions}

\subsubsection{Running out of Stack or Actions}

Naigama parsing is a left recursing, meaning that the following
expression:

\begin{myquote}
\begin{verbatim}
INPUT <- ( { . } INPUT ) / ( { . } !. )

\end{verbatim}
\end{myquote}

will be compiled to bytecode that will incur, during its execution,
a stack that is as long as its input, and after execution, will result
in an action list that is as long as the input. Given that Naigama
allows you to process ('arbitrarily') large inputs, this may not
be something that the memory limits of your engine can handle.

When the engine encounters limits on its room for stack or action
list elements, it must hald execution of the bytecode abnormally.

\subsubsection{Streaming Input}

Given that each FAIL cleans up the stack completely until the first
'catch' element, input offsets before the input offset mentioned in the
engine's saved state in the first stack 'catch' item (seen from the top,
if it's given that stacks grown down), can be discarded by the engine,
allowing a streaming model of input provisioning.

\subsubsection{Endless Loops}

Endless loop detection, for a Naigama bytecode execution engine, is
relatively easy: the second time the same combination of bytecode offset
and input position is encountered, an endless loop is occurring, and the
engine should halt execution of the bytecode abnormally.

\subsubsection{Faulty Bytecode / Canary Traps}

Bytecode instruction values have been chosen in such a manner, that the
Hamming distance between them is always two or more, meaning that it
requires more than two bit upset events in an instruction, to potentially
be confused with another.

Addresses are always a multiple of four, so the two least relevant bits
on an address must always be zero.

Compilers may introduce noops or traps in regions that they know should
not ever be jumped to, for example by surrounding good code with them;
the assembly languages expressly allows for this (the 'trap' instruction).

\subsection{Output States}

The engine may exit for the following (negative) reasons:

\begin{itemize}

\item Because a FAIL condition ate up the entire stack, indicating
the the input did not match the compiled pattern or rules.
This is desired behavior.

\item Because the bytecode was correct, but behaved unacceptably
(\textit{ie} room on the stack ran out, or an endless loop was detected).
This is undesirable behavior; better bytecode must be produced
or better engine tuning must be done.

\item Because the bytecode had errors in it
(faulty instruction, faulty offset). This is undesirable behavior;
the bytecode must be re-generated, or a bit upset event must be assumed.

\end{itemize}

And it may be used, when successful, in the following ways:

\begin{itemize}

\item An 'end' instruction was encountered (there was a match).

\item An 'end' instruction was encountered, including an end code
(when a pattern yields several success end points).

\item The action list can be used, read-only on the input (captures).

\item The action list can be used, read-write on the input
(captures / replacements).

\end{itemize}

\subsection{Execution}

When the engine runs bytecode, it will start with the instruction
at bytecode offset zero. It will read and execute this instruction
and run each subsequent instruction (either because it was jumped to
or because it was logically the next instruction).
This loop will continue either until the stack is made empty by a FAIL
condition, or an 'end' instruction is encountered
(or any of the abnormal conditions as noted above were encountered).

The following permutations of the engine's state exist during this loop:

\subsubsection{FAIL}

The FAIL condition is invoked automatically when instructions
that implement input matching, fail, but it may also be invoked
expressly by the 'fail' and 'failtwice' instructions.

A FAIL condition starts eating up the stack, until it encounters
a 'catch' element. When that happens, the 'catch' element is popped,
the state of the engine captured therein is restored, and the engine
jumps to the offset encapsulated therein.

When no 'catch' element is encountered on its way to the top of the stack,
the execution ultimately ends with failure.

\subsubsection{Instruction: Any}

The any instruction checks to see if there is a byte left in the input
and if so, consumes it (by jumping one position forward in the input),
and goes on to the next instruction.

If there is no byte left in the input, then a FAIL is invoked.

\subsubsection{Instruction: Backcommit}

The backcommit instruction eats up the stack like FAIL does,
reconstituting the state captured in the popped, topmost 'catch' element,
but instead of jumping to the offset captured therein, it jumps to
a given parameter offset.

\subsubsection{Instruction: Call}

The call instruction pushes a 'call' element on the stack, which contains
a bytecode offset to continue from (the next instruction), once the
corresponding 'ret' instruction pops this element off the stack.

\subsubsection{Instruction: Catch}

The catch instruction pushes a 'catch' element on the stack, capturing
the current state, and a bytecode offset to jump to, when the FAIL
condition pops this element.

\subsubsection{Instruction: Char}

The char instruction checks to see if there is a byte left in the input
and if so and if it compares to the given parameter character value, 
consumes it (by jumping one position forward in the input),
and goes on to the next instruction.

If there is no byte left in the input, then a FAIL is invoked.

\subsubsection{Instruction: Closecapture}

The closecapture instruction pushes a 'closecapture' element on the
action list, for the given parameter slot value (and the current
input position).

\subsubsection{Instruction: Commit}

The commit instruction pops the topmost element off the stack
(which must be a 'catch' element), then jumps to the given
parameter bytecode offset.

\subsubsection{Instruction: Condjump}

The condjump instruction jumps to the bytecode offset value
of the second parameter, if the number value stored in the register
of the first parameter is not one. Then it decreases the value of the
register.

\subsubsection{Instruction: Counter}

The counter instruction stores the number value of the second parameter
into the register of the first parameter.

\subsubsection{Instruction: End}

The end instruction halts the bytecode execution. The number value
of the parameter is passed to the initiator of the execution.

\subsubsection{Instruction: Fail}

Invokes the FAIL condition.

\subsubsection{Instruction: Failtwice}

Invokes the FAIL condition, twice. That is to say, breaking through
the first 'catch' element encountered on the stack, to the second;
without jumping to the bytecode offset encapsulated in the first one,
but instead to the second.

\subsubsection{Instruction: Jump}

The jump instruction jumps to the bytecode offset given as its parameter.

\subsubsection{Instruction: Noop}

The noop instruction does nothing, but move to the next instruction.

\subsubsection{Instruction: Opencapture}

The closecapture instruction pushes an 'opencapture' element on the
action list, for the given parameter slot value (and the current
input position).

\subsubsection{Instruction: Partialcommit}

The partialcommit instruction takes the topmost element of the stack,
which must be a 'catch' element, and updates the input position
encapsulated therein to the current input position, then jumps to
the bytecode offset given as parameter value.

\subsubsection{Instruction: Quad}

The quad instruction implements the 'char' instruction, but then for
four consecutive character matches in one go. So, the engine checks
to see if the input position allows for four matches, then matches them.
Otherwise it invokes the FAIL condition.

\subsubsection{Instruction: Replace}

\subsubsection{Instruction: Replacestring}

\subsubsection{Instruction: Ret}

The ret instruction pops the topmost element off the stack, which must
be a 'call' element, and jumps to the bytecode offset encapsulated therein.

\subsubsection{Instruction: Set}

\subsubsection{Instruction: Skip}

\subsubsection{Instruction: Skipvar}

\subsubsection{Instruction: Span}

\subsubsection{Instruction: Testany}

\subsubsection{Instruction: Testchar}

\subsubsection{Instruction: Testquad}

\subsubsection{Instruction: Testset}

\subsubsection{Instruction: Trap}

The trap instruction causes the bytecode execution to fail abnormally,
and the engine to halt. Compilers may emit this instruction in places
where the engine must never end up.

\subsubsection{Instruction: Var}
