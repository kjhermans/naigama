\subsection{Instruction: maskedchar}

\subsubsection{Summary}

The 'maskedchar' instruction compares the masked current input byte
against a character value paramater.
If they are
equal, the match is considered a success, and the engine moves to the
next instruction. If they are not equal, the FAIL condition is raised.

\subsubsection{Grammar and Compiling}

In grammar, the 'maskedchar' instruction is emitted by the compiler
when the following pattern occurs.

\begin{myquote}
\begin{verbatim}
MASKEDCHAR <- |40|80|

\end{verbatim}
\end{myquote}

This would result in the following evaluation of code, in C:

\begin{myquote}
\begin{verbatim}
if ((inputbyte & 0x80) == 0x40) {
  goto NEXT;
} else {
  goto FAIL;
}

\end{verbatim}
\end{myquote}

Note that the input pointer is not increased on success.

\subsubsection{Assembly Syntax}

\begin{myquote}
\begin{verbatim}
MASKEDCHARINSTR <- { 'maskedchar' } S HEXBYTE S HEXBYTE
S               <- %s+
HEXBYTE         <- [0-9a-fA-F]^2

\end{verbatim}
\end{myquote}

\subsubsection{Bytecode Encoding}

This instruction is structured in bytecode as follows:

%DEADBEEF
$_0$\ 
\fbox{%
  \parbox{20pt}{%
00
  }%
}
\fbox{%
  \parbox{20pt}{%
08
  }%
}
\fbox{%
  \parbox{20pt}{%
03
  }%
}
\fbox{%
  \parbox{20pt}{%
7e
  }%
}

%DEADBEEF

$_4$\
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}

$_8$\
\fbox{%
  \parbox{20pt}{%
mm
  }%
}
\fbox{%
  \parbox{20pt}{%
mm
  }%
}
\fbox{%
  \parbox{20pt}{%
mm
  }%
}
\fbox{%
  \parbox{20pt}{%
mm
  }%
}

Where 'nn' is a 32-bit, network encoded, masked character value.

Where 'mm' is a 32-bit, network encoded, character mask.

\subsubsection{Execution State Change}

.

Original state: \textit{(p, i, e, c)}

Operation: \textbf{maskedchar c m}; ( i \& m ) = c

Failure state: \textit{(\textbf{Fail}, i, e, c)}

Success state: \textit{(p + 1, i, e, c)}

