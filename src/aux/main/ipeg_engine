#!/usr/bin/perl

use Data::Dumper;

##
## Usage: $0 [options] <bytecodefile> <inputfile>
## Options: -d       Set debug
##          -s n     Set stack size n
##

my $stacksize = 512;
my $debug;

while ($ARGV[0] =~ s/^-//) {
  my $options = shift @ARGV;
  while ($options =~ s/^(.)//s) {
    if ($1 eq 'd') {
      $debug = 1;
    } elsif ($1 eq 's') {
      $stacksize = int(shift(@ARGV)) || die "Need stack size bigger than zero";
    }
  }
}

my $bytecodefile = shift @ARGV;
my $textfile = shift @ARGV;

my $labelmapfile = $bytecodefile; $labelmapfile .= ".labelmap";
my $defsfile = $bytecodefile; $defsfile =~ s/\.byc$/.asm.definitions/;

my ($labelmap, $defs);

if (-f $labelmapfile) {
  if ($debug) { print STDERR "Loading labelmap from $labelmapfile.\n"; }
  $labelmap = eval( `cat $labelmapfile` );
}

if (-f $defsfile) {
  if ($debug) { print STDERR "Loading definitions from $defsfile.\n"; }
  $defs = eval( `cat $defsfile` );
}

if ($debug) {
  print STDERR "Reading $bytecodefile, $textfile.\n";
}

sub absorb_binary
{
  my $result = '';
  my $path = shift; die "$path not found" if (! -f $path);
  die "Error $@ opening $bytecodefile" if (!open(FILE, '<', $path));
  binmode FILE;
  my $buf;
  while (1) {
    my $n = sysread(FILE, $buf, 1024);
    if (!$n) {
      close FILE;
      return $result;
    }
    $result .= $buf;
  }
}

# my $bc = absorb_binary($bytecodefile);
my $txt = absorb_binary($textfile);

use IPEG::Engine;

my $engine = IPEG::Engine->new(); ## $bc);
$engine->set_file($bytecodefile);
if ($debug) { $engine->set_debug(1); }
$engine->{stack_max} = $stacksize;
if ($labelmap) { $engine->set_labelmap($labelmap); }
my $result = $engine->run($txt);

print STDERR Dumper $result;

1;
