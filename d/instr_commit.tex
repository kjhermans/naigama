\subsection{Instruction: commit}

\subsubsection{Summary}

The 'commit' instruction pops the topmost 'catch' element off the stack,
and jumps to the bytecode offset given as a parameter in the instruction.

\subsubsection{Grammar and Compiling}

Anywhere where the execution of a branch is considered successful,
this instruction is emitted by the compiler.

\subsubsection{Assembly Syntax}

\begin{myquote}
\begin{verbatim}
COMMITINSTR <- 'commit' S LABEL
S           <- %s+
LABEL       <- [a-zA-Z0-9_]^1-64

\end{verbatim}
\end{myquote}

\subsubsection{Bytecode Encoding}

This instruction is structured in bytecode as follows:

%DEADBEEF
$_0$\ 
\fbox{%
  \parbox{20pt}{%
00
  }%
}
\fbox{%
  \parbox{20pt}{%
04
  }%
}
\fbox{%
  \parbox{20pt}{%
0a
  }%
}
\fbox{%
  \parbox{20pt}{%
05
  }%
}

%DEADBEEF

$_4$\
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}

Where 'nn' is a 32-bit, network encoded, valid bytecode offset.

\subsubsection{Execution State Change}

.

Original state: \textit{(p, i, e, c)}

Operation: \textbf{commit n}

Failure state: -

Success state: \textit{(n, i, e-1, c)}

