\subsection{Instruction: char}

\subsubsection{Summary}

The 'char' instruction compares its only parameter, a character value,
against the character value at the current input offset. If they are
equal, the match is considered a success, and the engine moves to the
next instruction. If they are not equal, the FAIL condition is raised.

\subsubsection{Grammar and Compiling}

In grammar, the 'char' instruction is emitted by the compiler from
the treatment of a string literal.

\subsubsection{Assembly Syntax}

\begin{myquote}
\begin{verbatim}
CHARINSTR <- 'char' S HEXBYTE
S         <- %s+
HEXBYTE   <- [0-9a-fA-F]^2

\end{verbatim}
\end{myquote}
\subsubsection{Bytecode Encoding}

This instruction is structured in bytecode as follows:

%DEADBEEF
$_0$\ 
\fbox{%
  \parbox{20pt}{%
00
  }%
}
\fbox{%
  \parbox{20pt}{%
04
  }%
}
\fbox{%
  \parbox{20pt}{%
05
  }%
}
\fbox{%
  \parbox{20pt}{%
09
  }%
}

%DEADBEEF

$_4$\
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}

Where 'nn' is a 32-bit, network encoded, character value.

\subsubsection{Execution State Change}

.

Original state: \textit{(p, i, e, c)}

Operation: \textbf{char c}

Failure state: \textit{(\textbf{Fail}, i, e, c)}

Success state: \textit{(p + 1, i + 1, e, c)}

