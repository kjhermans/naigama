\subsection{Instruction: backcommit}

\subsubsection{Summary}

The 'backcommit' instruction pops the topmost element off the stack,
which MUST be a 'catch' element, restores the state captured therein,
but does not jump to the bytecode offset captured therein, but instead
to an offset given in the instruction itself.

\subsubsection{Grammar and Compiling}

The 'backcommit' instruction is emitted by the compiler when, in grammar,
the '\&' (ampersand) operator is used with a matcher, meaning: match,
but don't advance. If matcher
is $<$M$>$, and the pattern given is \&$<$M$>$, then the emitted pattern
is as follows:

\begin{myquote}
\begin{verbatim}
catch L0
<M>
backcommit L1
L0:
fail
L1:

\end{verbatim}
\end{myquote}

\subsubsection{Assembly Syntax}

\begin{myquote}
\begin{verbatim}
BACKCOMMITINSTR <- 'backcommit' S LABEL
S               <- %s+
LABEL           <- [a-zA-Z0-9_]^1-64

\end{verbatim}
\end{myquote}
\subsubsection{Bytecode Encoding}

This instruction is structured in bytecode as follows:

%DEADBEEF
$_0$\ 
\fbox{%
  \parbox{20pt}{%
00
  }%
}
\fbox{%
  \parbox{20pt}{%
04
  }%
}
\fbox{%
  \parbox{20pt}{%
03
  }%
}
\fbox{%
  \parbox{20pt}{%
3a
  }%
}

%DEADBEEF

$_4$\ 
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}
\fbox{%
  \parbox{20pt}{%
nn
  }%
}

Where 'nn' is a 32-bit, network encoded, valid bytecode offset.

\subsubsection{Execution State Change}

.

Original state: \textit{(p, i, e, c)}

Operation: \textbf{backcommit n}

Failure state: -

Success state: \textit{(n, e:i, e-1, e:c)}

